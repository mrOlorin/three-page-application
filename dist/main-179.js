(()=>{var e,r,t={112:(e,r,t)=>{"use strict";t.d(r,{Z:()=>o});var n=t(645),i=t.n(n)()((function(e){return e[1]}));i.push([e.id,"header,nav{display:inline-block}header nav{padding:15px}header nav a{display:block;padding:10px}a{color:#000}a:hover{color:#008}body{width:400px}",""]);const o=i},538:(e,r,t)=>{"use strict";t.d(r,{Z:()=>n});class n{static toArr3(e){return"number"==typeof e&&(e=[e,e,e]),e}static cubePosition(e,r=[1,1,1],t=[1,1,1]){return r=n.toArr3(r),[(t=n.toArr3(t))[0]*(e%r[0]),t[1]*(Math.floor(e/r[0])%r[1]),t[2]*Math.floor(e/(r[1]*r[2]))]}static rand(e){return(.5-Math.random())*e}}},559:(e,r,t)=>{"use strict";var n=t(379),i=t.n(n),o=t(112);i()(o.Z,{insert:"head",singleton:!1}),o.Z.locals;var a=t(212),s=t(886),l=t(564);class c{constructor(){this.onWindowResize=()=>{this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.fov=360/Math.PI*Math.atan(this.tanFOV*(window.innerHeight/1080)),this.camera.updateProjectionMatrix(),this.webGLRenderer.setSize(window.innerWidth,window.innerHeight),this.css3DRenderer.setSize(window.innerWidth,window.innerHeight)},this.webGLRenderer=c.initWebGLRenderer(),this.css3DRenderer=c.initCSS3DRenderer(),this.domElement=c.initDOMElement(this.webGLRenderer,this.css3DRenderer),this.initCamera(),window.addEventListener("resize",this.onWindowResize,!1),this.onWindowResize(),this.initRenderLoop()}animate(){this.scene&&(this.webGLRenderer.render(this.scene,this.camera),this.css3DRenderer.render(this.scene,this.camera)),this.controls.update()}initRenderLoop(){const e=()=>{this.animate(),requestAnimationFrame(e)};e()}initCamera(){this.camera=new a.cPb,this.camera.far=1e9,this.camera.near=1e-9,this.tanFOV=Math.tan(Math.PI/180*this.camera.fov/2),this.controls=new s.z(this.camera,this.css3DRenderer.domElement),this.controls.enableDamping=!0,this.controls.dampingFactor=.1}static initDOMElement(e,r){const t=document.createElement("div"),n=document.createElement("div"),i=document.createElement("div");return n.appendChild(e.domElement),i.appendChild(r.domElement),t.appendChild(n),t.appendChild(i),t}static initWebGLRenderer(){const e=new a.CP7({alpha:!0,antialias:!0,logarithmicDepthBuffer:!0});return e.setClearColor(0,0),e.setPixelRatio(window.devicePixelRatio),e.shadowMap.enabled=!0,e.shadowMap.type=a.ntZ,e.domElement.style.position="absolute",e.domElement.style.top="0",e.domElement.style.bottom="0",e.domElement.style.left="0",e.domElement.style.zIndex="-1",e}static initCSS3DRenderer(){const e=new l.lX;return e.setSize(window.innerWidth,window.innerHeight),e.domElement.style.position="absolute",e.domElement.style.top="0",e.domElement.style.bottom="0",e.domElement.style.left="0",e.domElement.style.zIndex="-1",e}}class d{constructor(e,r){}requiresDestroy(){return"onDestroy"in this}}class h extends d{constructor(){super(),this.scene=new a.xsS,this.scene.background=new a.Ilk(.95,.95,1),this.root=new a.Tme,this.scene.add(this.root),this.root.add(h.buildCube()),this.setLight()}static buildCube(){const e=new a.DvJ(100,200,50),r=new a.xoR({color:1401481,emissive:0,specular:1118481,side:a.Wl3,shininess:30});return new a.Kj0(e,r)}setLight(){this.scene.add(new a.Mig(1118481));const e=new a.Ox3(16777215,1);e.position.set(5,1,3).normalize(),this.scene.add(e);const r=new a.cek(16777215,1,100);r.position.set(10,10,10),this.scene.add(r)}}var u=t(127),m=t.n(u),f=t(188),p=t.n(f);class v extends a.woe{constructor(){super(),this.scaleFactor=100,this.onBeforeRender=()=>{this.material.uniforms.uTime.value=1e-5*performance.now()},this.initGeometry(),this.initMaterial(),this.scale.set(this.scaleFactor,this.scaleFactor,this.scaleFactor)}initGeometry(){this.geometry=new a.u9r;const e=[],r=[],t=[];for(let n=0;n<1e5;n++)e.push(.5-Math.random(),.5-Math.random(),.5-Math.random()),r.push(Math.random(),Math.random(),Math.random()),t.push(Math.random()*this.scaleFactor);this.geometry.setAttribute("position",new a.a$l(e,3)),this.geometry.setAttribute("color",new a.a$l(r,3)),this.geometry.setAttribute("size",new a.a$l(t,1).setUsage(a.dj0))}initMaterial(){this.material=new a.jyz({uniforms:{uTime:{value:0},pointTexture:{value:(new a.dpR).load("assets/textures/sprites/disc.png")}},glslVersion:a.LSk,vertexShader:m(),fragmentShader:p(),blending:a.bdR,depthTest:!1,transparent:!0,vertexColors:!0})}}class g extends a.Tme{constructor(e=8){super(),this.attract=(()=>{const e=new a.yGw,r=new a.Pa4(0,1,0),t=new a.Pa4;return n=>{for(let i=0,o=Math.pow(this.size,3);i<o;i++){this.electricArrows.getMatrixAt(i,e),t.setFromMatrixPosition(e),e.lookAt(n,t,r),t.sub(n);const o=Math.min(1/t.lengthSq(),1);t.setScalar(o),e.scale(t),this.electricArrows.setMatrixAt(i,e)}this.electricArrows.instanceMatrix.needsUpdate=!0}})(),this.cubicPosition=(()=>{const e=new a.Pa4;return(r,t)=>(e.set(r%t,Math.floor(r/t)%t,Math.floor(r/(t*t))),e)})(),this.size=e,this.electricArrows=this.initArrows(),this.add(this.electricArrows)}initArrows(){const e=new a.m_w(0,.03,1,12);e.rotateX(Math.PI/2);const r=new a.Wid;r.color.set(0);const t=new a.SPe(e,r,Math.pow(this.size,3)),n=new a.Tme;for(let e=0;e<Math.pow(this.size,3);e++){const r=this.cubicPosition(e,this.size);n.position.copy(r),n.updateMatrix(),t.setMatrixAt(e,n.matrix)}return t}}class y extends a.Kj0{constructor(){super(),this.geometry=new a.Aip(.1,8,8),this.material=new a.vBJ({color:16711680})}}var x=t(431),w=t(121),P=t(546);const b=[x.default,w.default,P.default];var S=t(457),z=t(210);class q{constructor(e){if(this.config=e,this.compute=(e,r)=>{this.positionVariable.material.uniforms.t.value=e,this.velocityVariable.material.uniforms.t.value=e,this.positionVariable.material.uniforms.dt.value=r,this.velocityVariable.material.uniforms.dt.value=r,this.gpuCompute.compute(),this.config.target.positions.value=this.gpuCompute.getCurrentRenderTarget(this.positionVariable).texture,this.config.target.velocities.value=this.gpuCompute.getCurrentRenderTarget(this.velocityVariable).texture},this.config.size%1!=0)throw new Error("Unequal sides");this.initComputationRenderer()}readTexture(e,r){return this.config.renderer.readRenderTargetPixels(e,0,0,this.config.size,this.config.size,r),r}initComputationRenderer(){const e=new z.n(this.config.size,this.config.size,this.config.renderer),r=e.createTexture(),t=e.createTexture();this.config.fillPositions(r.image.data),this.config.fillVelocities(t.image.data,r.image.data),this.positionVariable=e.addVariable("texturePosition",this.config.positionShader,r),this.position=new Float32Array(this.config.size*this.config.size*4),this.readPositions=()=>(this.readTexture(this.gpuCompute.getCurrentRenderTarget(this.positionVariable),this.position),this.position),this.velocityVariable=e.addVariable("textureVelocity",this.config.velocityShader,t),this.velocity=new Float32Array(this.config.size*this.config.size*4),this.readVelocities=()=>(this.readTexture(this.gpuCompute.getCurrentRenderTarget(this.velocityVariable),this.velocity),this.velocity),e.setVariableDependencies(this.velocityVariable,[this.positionVariable,this.velocityVariable]),e.setVariableDependencies(this.positionVariable,[this.positionVariable,this.velocityVariable]),this.positionVariable.material.uniforms.t={value:0},this.positionVariable.material.uniforms.dt={value:0},this.velocityVariable.material.uniforms.t={value:0},this.velocityVariable.material.uniforms.dt={value:0};const n=e.init();if(null!==n)throw new Error(n);this.gpuCompute=e}}class M extends S.T{constructor(e){super(),this.renderer=e}loadState(e){return r=this,t=void 0,i=function*(){const r=this.buildPoints(e.count,e.vertexShader,e.fragmentShader);r.frustumCulled=!1;let t=Math.sqrt(e.count);t%1!=0&&(t=Math.ceil(t),console.info(`Count ${e.count} is not power of 2, we'll create ${Math.pow(t,2)} points`));const n=r.material,i=new q({renderer:this.renderer,size:t,fillPositions:e.fillPositions,fillVelocities:e.fillVelocities,positionShader:e.positionShader,velocityShader:e.velocityShader,target:{positions:n.uniforms.texturePosition,velocities:n.uniforms.textureVelocity}});let o=0;const a=.01;r.onBeforeRender=()=>{i.compute(o,a),n.uniforms.dt.value=a,n.uniforms.t.value=o,o+=a},this.points&&this.remove(this.points),this.points=r,this.add(this.points)},new((n=void 0)||(n=Promise))((function(e,o){function a(e){try{l(i.next(e))}catch(e){o(e)}}function s(e){try{l(i.throw(e))}catch(e){o(e)}}function l(r){var t;r.done?e(r.value):(t=r.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}l((i=i.apply(r,t||[])).next())}));var r,t,n,i}buildPoints(e,r,t){const n=this.initGeometry(e),i=window.innerHeight/(Math.tan(.5*a.M8C.DEG2RAD*90)/3),o=new a.jyz({uniforms:{cameraConstant:{value:i},texturePosition:{value:null},textureVelocity:{value:null},dt:{value:0},t:{value:0}},transparent:!0,vertexShader:r,fragmentShader:t,depthTest:!0,depthWrite:!0,glslVersion:a.LSk,precision:"highp"});return new a.woe(n,o)}initGeometry(e){const r=new a.u9r,t=new Float32Array(3*e);return r.setAttribute("position",new a.a$l(t,3)),r.setAttribute("uv",new a.a$l((e=>{const r=new Float32Array(e*e*2);let t=0;for(let n=0;n<e;n++)for(let i=0;i<e;i++)r[t++]=i/(e-1),r[t++]=n/(e-1);return r})(Math.sqrt(e)),2)),r}}class D extends S.T{constructor(e,r,t){super(),this.points=this.buildPoints(e,r,t),this.material=this.points.material,this.add(this.points)}buildPoints(e,r,t){const n=this.initGeometry(e),i=window.innerHeight/(Math.tan(.5*a.M8C.DEG2RAD*90)/1.0000001),o=new a.jyz({uniforms:{cameraConstant:{value:i},texturePosition:{value:null},textureVelocity:{value:null},dt:{value:0},t:{value:0}},transparent:!0,vertexShader:r,fragmentShader:t,colorWrite:!0,depthWrite:!0,glslVersion:a.LSk,precision:"highp",blending:a.bdR}),s=new a.woe(n,o);return s.frustumCulled=!1,s}initGeometry(e){const r=new a.u9r,t=new Float32Array(3*e);return r.setAttribute("position",new a.a$l(t,3)),r.setAttribute("uv",new a.a$l((e=>{const r=new Float32Array(e*e*2);let t=0;for(let n=0;n<e;n++)for(let i=0;i<e;i++)r[t++]=i/(e-1),r[t++]=n/(e-1);return r})(Math.sqrt(e)),2)),r}}var C=t(354),T=t.n(C),_=t(130),R=t.n(_),E=t(538);class I extends a.woe{constructor(){super(),this.rayOrigin=new a.Pa4(0,0,0),this.rayDirection=new a.Pa4(0,0,0),this.uglyFix=new a.Pa4(-1,-1,1),this.onBeforeRender=(e,r,t)=>{t.getWorldPosition(this.rayOrigin),t.getWorldDirection(this.rayDirection),this.material.uniforms.rayOrigin.value.copy(this.rayOrigin.multiply(this.uglyFix)),this.material.uniforms.rayDirection.value.copy(this.rayDirection.multiply(this.uglyFix)),this.material.uniforms.uTime.value=.001*performance.now()},this.initGeometry(),this.initMaterial(),this.matrixAutoUpdate=!0}initGeometry(){this.geometry=new a.u9r;const e=[100,100,1],r=[];for(let t=0,n=3*Math.pow(100,2);t<n;t+=3){let n=E.Z.cubePosition(t/3,e,20);r[t]=n[0]-20*e[0]*.5,r[t+1]=n[1]-20*e[1]*.5,r[t+2]=0}this.geometry.setAttribute("position",new a.a$l(r,3))}initMaterial(){this.material=new a.jyz({vertexShader:T(),fragmentShader:R(),uniforms:{uTime:{value:0},rayOrigin:{value:new a.Pa4},rayDirection:{value:new a.Pa4}},glslVersion:a.LSk})}}var O=t(378),F=t.n(O),k=t(915),A=t.n(k);const V={box:h,points:class extends d{constructor(){super(),this.scene=new a.xsS;const e=new v;e.scale.setScalar(2e3),this.scene.add(e)}},field:class extends d{constructor(e){super(),this.particles=[],this.onBeforeRender=()=>{this.particles.forEach((e=>{e.position.x=3+2*Math.cos(this.time),e.position.y=3+2*Math.sin(this.time),e.position.z=3,this.vectorField.attract(e.position)}))},this.vectorField=new g,this.scene=new a.xsS,this.scene.add(this.vectorField),e.camera.position.set(5,3,20),this.scene.add(new a.y8_(1)),this.particles.push(new y),this.scene.add(this.particles[0]),this._time=.001*performance.now(),this.scene.onBeforeRender=this.onBeforeRender}get time(){return.001*performance.now()-this._time}},el:class extends d{constructor(e,r){super(),this.world=e,this.urlSegments=r,this.scene=new a.xsS,this.particles=new M(e.webGLRenderer),this.scene.add(this.particles);const t=r[0];this.loadState(t||"random"),this.scene.add(this.buildNav())}buildNav(){const e=document.createElement("nav");b.map((r=>{const t=document.createElement("p"),n=document.createElement("a");n.setAttribute("href",`#el/${r.id}`),n.textContent=r.id,t.appendChild(n),e.appendChild(t)}));const r=new l.cp(e);return r.position.x=-300,r}loadState(e){return r=this,n=void 0,o=function*(){const r=(yield t(57)(`./${e}`)).default;this.particles.loadState(r)},new((i=void 0)||(i=Promise))((function(e,t){function a(e){try{l(o.next(e))}catch(e){t(e)}}function s(e){try{l(o.throw(e))}catch(e){t(e)}}function l(r){var t;r.done?e(r.value):(t=r.value,t instanceof i?t:new i((function(e){e(t)}))).then(a,s)}l((o=o.apply(r,n||[])).next())}));var r,n,i,o}},thomas:class extends d{constructor(e){super(),this.world=e,this.t=0,this.dt=.001,this.scene=new a.xsS,this.loadState("kubik")}loadEnvironment(){(new a.dpR).load("assets/table_mountain_1.jpg",(e=>{const r=new a.oAp(e.image.height);r.fromEquirectangularTexture(this.world.webGLRenderer,e),this.scene.background=r}))}loadState(e){return r=this,n=void 0,o=function*(){const r=(yield t(497)(`./${e}`)).default;this.particles=new D(r.count,r.vertexShader,r.fragmentShader),this.particles.scale.setScalar(80),this.initComputer(r,this.particles.material),this.scene.add(this.particles)},new((i=void 0)||(i=Promise))((function(e,t){function a(e){try{l(o.next(e))}catch(e){t(e)}}function s(e){try{l(o.throw(e))}catch(e){t(e)}}function l(r){var t;r.done?e(r.value):(t=r.value,t instanceof i?t:new i((function(e){e(t)}))).then(a,s)}l((o=o.apply(r,n||[])).next())}));var r,n,i,o}initComputer(e,r){let t=Math.sqrt(e.count);t%1!=0&&(t=Math.ceil(t),console.info(`Count ${e.count} is not power of 2, we'll create ${Math.pow(t,2)} points`));const n=r,i=new q({renderer:this.world.webGLRenderer,size:t,fillPositions:e.fillPositions,fillVelocities:e.fillVelocities,positionShader:e.positionShader,velocityShader:e.velocityShader,target:{positions:n.uniforms.texturePosition,velocities:n.uniforms.textureVelocity}});n.uniforms.dt.value=this.dt,this.scene.onBeforeRender=()=>{i.compute(this.t,this.dt),n.uniforms.t.value=this.t,this.t+=this.dt}}},rings:class extends d{constructor(){super(),this.scene=new a.xsS;const e=new I;this.scene.add(e)}},raymarching:class extends d{constructor(e){super(),this.scene=new a.xsS,this.root=new a.Tme,this.scene.add(this.root),this.root.add(this.buildCube()),e.camera.position.set(0,0,20)}buildCube(){const e=new a.nvb(1e6,1e6,1e6);this.material=new a.jyz({uniforms:{uTime:{value:0},pointTexture:{value:(new a.dpR).load("assets/textures/sprites/disc.png")},rayOrigin:{value:new a.Pa4},rayDirection:{value:new a.Pa4},resolution:{value:new a.FM8(window.innerWidth,window.innerHeight)}},glslVersion:a.LSk,vertexShader:F(),fragmentShader:A(),blending:a.jFi,depthTest:!1,transparent:!0,side:a._Li}),window.addEventListener("resize",(()=>{this.material.uniforms.resolution.value.set(window.innerWidth,window.innerHeight)}));const r=new a.SPe(e,this.material,1);return r.onBeforeRender=(e,r,t)=>{t.getWorldPosition(this.material.uniforms.rayOrigin.value),t.getWorldDirection(this.material.uniforms.rayDirection.value),this.material.uniforms.uTime.value=.001*performance.now()},r}}},L=new c;let B;const N=()=>{return e=void 0,r=void 0,n=function*(){B&&(B.requiresDestroy()&&B.onDestroy(),B.scene.clear()),L.camera.position.set(0,0,1e3);const e=new URL(window.location.href).hash.split("/"),r=e.shift().substring(1),t=V[r];t||(window.location.href="#box"),B=new t(L,e),L.scene=B.scene},new((t=void 0)||(t=Promise))((function(i,o){function a(e){try{l(n.next(e))}catch(e){o(e)}}function s(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var r;e.done?i(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(a,s)}l((n=n.apply(e,r||[])).next())}));var e,r,t,n};document.body.addEventListener("click",(e=>{e.target instanceof HTMLAnchorElement&&e.target.matches("[data-link]")&&(e.preventDefault(),history.pushState(null,null,e.target.href),N())})),document.addEventListener("DOMContentLoaded",N),window.addEventListener("popstate",N),document.body.appendChild(L.domElement)},431:(e,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>p});var n=t(538),i=t(467),o=t.n(i),a=t(96),s=t.n(a),l=t(641),c=t.n(l),d=t(749),h=t.n(d),u=t(507),m=t.n(u);const f={id:"cube",count:Math.pow(125,2),vertexShader:h(),fragmentShader:m(),positionShader:o(),velocityShader:s().replace(/\/\/ {{velocityFunction}}/,c()),fillPositions:e=>{let r=1e3;for(let t=0,i=4*f.count;t<i;t+=4){let i=n.Z.cubePosition(t/4,25,20);e[t]=i[0]-250,e[t+1]=i[1]-250,e[t+2]=i[2]-250,e[t+3]=r*Math.random(),r=1001-r}},fillVelocities:e=>{let r=1;for(let t=0,n=4*f.count;t<=n;t+=4)e[t]=0,e[t+1]=0,e[t+2]=0,e[t+3]=r,r=-r}},p=f},121:(e,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>p});var n=t(538),i=t(467),o=t.n(i),a=t(96),s=t.n(a),l=t(641),c=t.n(l),d=t(749),h=t.n(d),u=t(507),m=t.n(u);const f={id:"flat",count:Math.pow(125,2),vertexShader:h(),fragmentShader:m(),positionShader:o(),velocityShader:s().replace(/\/\/ {{velocityFunction}}/,c()),fillPositions:e=>{const r=[120,1,120];for(let t=0,i=4*f.count;t<i;t+=4){let i=n.Z.cubePosition(t/4,r,5);e[t]=i[0]-5*r[0]*.5,e[t+1]=i[1]-150,e[t+2]=-i[2]+5*r[2]*.5,e[t+3]=10}},fillVelocities:e=>{let r=1;for(let t=0,n=4*f.count;t<=n;t+=4)e[t]=0,e[t+1]=0,e[t+2]=0,e[t+3]=r,r=-r}},p=f},546:(e,r,t)=>{"use strict";t.r(r),t.d(r,{default:()=>p});var n=t(538),i=t(467),o=t.n(i),a=t(96),s=t.n(a),l=t(641),c=t.n(l),d=t(749),h=t.n(d),u=t(507),m=t.n(u);const f={id:"random",count:Math.pow(125,2),vertexShader:h(),fragmentShader:m(),positionShader:o(),velocityShader:s().replace(/\/\/ {{velocityFunction}}/,c()),fillPositions:e=>{let r=1e3;for(let t=0,i=4*f.count;t<i;t+=4)e[t]=n.Z.rand(500),e[t+1]=n.Z.rand(500),e[t+2]=n.Z.rand(500),e[t+3]=r,r=1001-r},fillVelocities:e=>{let r=1;for(let t=0,n=4*f.count;t<=n;t+=4)e[t]=0,e[t+1]=0,e[t+2]=0,e[t+3]=r,r=-r}},p=f},507:e=>{e.exports="uniform sampler2D texturePosition;\r\nuniform sampler2D textureVelocity;\r\nuniform float dt;\r\nuniform float t;\r\nin vec2 particleId;\r\nout vec4 fragColor;\r\n\r\nconst float hBar = 1.;\r\n\r\nvec2 cExp(float x) {\r\n    float s = sin(x);\r\n    return vec2(-s, s) + cos(x);\r\n}\r\nvec2 psi(float p, float m) {\r\n    float E = 1.;\r\n\r\n    float K = sqrt(2. * m * E) / hBar;\r\n    float A = .07;\r\n    float B = .07;\r\n    float hBarKOverTwoMT = ((hBar * K) / 2. * m) * t * .0000001;\r\n    return A * cExp(K * (p - hBarKOverTwoMT)) + B * cExp(-K * (p + hBarKOverTwoMT));\r\n}\r\nfloat dist(vec3 ro, vec3 rd, vec3 p) {\r\n    return length(cross(p-ro, rd)) / length(rd);\r\n}\r\nvoid main() {\r\n    vec2 uv = gl_PointCoord - vec2(.5);\r\n    float cUv = length(uv);\r\n    float charge = texture(textureVelocity, particleId).w;\r\n    vec4 particlePosition = texture(texturePosition, particleId);\r\n\r\n    vec3 chargeColor = vec3(.548, 0., -.548);\r\n\r\n    vec3 ro = vec3(0, 0, -1.5);\r\n    vec3 rd = vec3(uv, 0) - ro;\r\n    vec3 p = vec3(0, 0, 0);\r\n    chargeColor.xy += psi(particlePosition.z, particlePosition.w);\r\n    chargeColor.yz += psi(particlePosition.x, particlePosition.w);\r\n    chargeColor.zx += psi(particlePosition.y, particlePosition.w);\r\n    float d = dist(ro, rd, p);\r\n\r\n    d = smoothstep(.5, 0., d);\r\n    fragColor = vec4(chargeColor * charge, d);\r\n}\r\n"},467:e=>{e.exports="uniform float time;\r\n\r\nvoid main() {\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec4 tmpPos = texture(texturePosition, uv);\r\n    vec3 position = tmpPos.xyz;\r\n    vec3 velocity = texture(textureVelocity, uv).xyz;\r\n\r\n    float phase = tmpPos.w;\r\n\r\n    gl_FragColor = vec4(position + velocity, phase);\r\n}\r\n"},641:e=>{e.exports="const float PI = 3.14159265358979323;\r\nconst float TWO_PI = 2.0 * PI;\r\nconst float FOUR_PI = 2.0 * TWO_PI;\r\nconst float THREE_BY_FOUR_PI = (3.0 / FOUR_PI);\r\nconst float ONE_THIRD = (1.0 / 3.0);\r\nconst float c = 137.;\r\nconst float cc = 137. * 137.;\r\nconst float FOUR_PI_BY_C = FOUR_PI / c;\r\n\r\nfloat radiusFromMass(float mass) {\r\n    const float density = 1.;\r\n    return pow(THREE_BY_FOUR_PI * mass / (density), ONE_THIRD);\r\n}\r\n\r\nvec3 rotateZ(vec3 r, float a) {\r\n    return r * mat3(\r\n    cos(a), sin(a), 0.,\r\n    -sin(a), cos(a), 0.,\r\n    0., 0., 1.);\r\n}\r\n\r\nvec4 length4(vec4 v1, vec4 v2) {\r\n    return vec4(1);\r\n}\r\nvoid interact(inout Particle selfParticle, in Particle anotherParticle) {\r\n    vec3 r = selfParticle.position - anotherParticle.position;\r\n    float distanceSquared = dot(r, r);\r\n    vec3 velocity = anotherParticle.velocity - selfParticle.velocity;\r\n    float charge = selfParticle.charge * anotherParticle.charge;\r\n\r\n    float srel = -dot(velocity, velocity) / (cc);\r\n    float rel = max(sqrt(1. + srel), 0.0000001);\r\n\r\n    //float E0 = selfParticle.mass * (c * c);\r\n\r\n    vec3 E = normalize(r) / distanceSquared;\r\n    vec3 Fe = charge * E;\r\n\r\n    //vec3 B = cross(velocity, Fe);\r\n    //vec3 Fb = cross(B, velocity);\r\n\r\n    vec3 Fl = Fe;// + Fb;\r\n    selfParticle.velocity += (dt * Fl) / (selfParticle.mass);\r\n}\r\nvoid interact1(inout Particle selfParticle, in Particle anotherParticle) {\r\n    vec3 r = selfParticle.position - anotherParticle.position;\r\n    float distanceSquared = dot(r, r);\r\n    float distance = sqrt(distanceSquared);\r\n\r\n    float charge = selfParticle.charge * anotherParticle.charge;\r\n    vec3 velocity = anotherParticle.velocity - selfParticle.velocity;\r\n    float velocitySquared = dot(velocity, velocity);\r\n\r\n    // float relSqrt = 1. / sqrt(1. - pow(sqrt(velocitySquared) / c, 2.));\r\n\r\n    vec3 srel = 1. - (velocity * velocity) / (c * c);\r\n    vec3 rel = sqrt(srel);\r\n    //vec3 P = (selfParticle.mass * velocity) / rel;\r\n    //vec3 Fe = normalize(r) * (charge / distanceSquared);\r\n    // vec3 Frel = (selfParticle.mass * c) / (selfParticle.mass * P);\r\n    //vec3 crossComponent = Fe - Fe + normalize(cross(velocity, Fe));\r\n    //Fe = (Fe - crossComponent) + crossComponent / rel;\r\n    //Fe = (F);\r\n\r\n    //vec3 qqr2 = normalize(r) * anotherParticle.charge * (selfParticle.charge / distanceSquared);\r\n    //vec3 Fe2 = qqr2 / rel;\r\n    //vec3 Fe3 = qqr2 * (sqrt(velocitySquared) / c) * (length(selfParticle.velocity) / (c * rel));\r\n\r\n    vec3 Fe4 = normalize(r) * anotherParticle.charge * (selfParticle.charge / (distanceSquared));\r\n\r\n    //vec3 E =  (normalize(r) * selfParticle.charge) / (distanceSquared * rel);\r\n    //vec3 B = ((normalize(r) * selfParticle.charge) / distanceSquared) * (length(selfParticle.velocity) / (c * rel));\r\n    //vec3 Fe5 = anotherParticle.charge * E - anotherParticle.charge * (length(anotherParticle.velocity) / c) * B;\r\n\r\n    /*vec3 beta = velocity / c;\r\n    float gamma = 1. / rel;\r\n    vec3 a = normalize(r) * anotherParticle.charge * (selfParticle.charge / (distanceSquared));\r\n    float m = selfParticle.mass*gamma;\r\n    vec3 Fe6 = m * gamma * a + m * pow(gamma, 3.) * beta * (beta * a);*/\r\n    vec3 P = (selfParticle.mass * velocity) / rel;\r\n    vec3 E = (selfParticle.mass * c * c) / rel;\r\n    vec3 E2 = P*P*c*c+selfParticle.mass*selfParticle.mass*c*c*c*c;\r\n\r\n    selfParticle.velocity += (dt * Fe4) / (selfParticle.mass);\r\n}\r\n"},96:e=>{e.exports="uniform float t;\r\nuniform float dt;\r\n\r\nstruct Particle {\r\n    vec3 position;\r\n    vec3 velocity;\r\n    float charge;\r\n    float mass;\r\n};\r\n\r\n// {{velocityFunction}}\r\n\r\nvoid fetchParticle(in vec2 uv, out Particle particle) {\r\n    vec4 positionData = texture2D(texturePosition, uv);\r\n    vec4 velocityData = texture2D(textureVelocity, uv);\r\n    particle.position = positionData.xyz;\r\n    particle.velocity = velocityData.xyz;\r\n    particle.mass = positionData.w;\r\n    particle.charge = velocityData.w;\r\n}\r\n\r\nconst float width = resolution.x;\r\nconst float height = resolution.y;\r\nconst vec2 size = vec2(width, height);\r\n\r\nvoid main() {\r\n    Particle selfParticle, anotherParticle;\r\n    vec2 selfId, anotherId;\r\n    selfId = gl_FragCoord.xy / size;\r\n    fetchParticle(selfId, selfParticle);\r\n    if (selfParticle.mass > 0.) {\r\n        for (float y = 0.0; y < height; y++) {\r\n            for (float x = 0.0; x < width; x++) {\r\n                anotherId = vec2(x + 0.5, y + 0.5) / size;\r\n                fetchParticle(anotherId, anotherParticle);\r\n                if (selfId == anotherId || anotherParticle.mass == 0.) continue;\r\n                interact(selfParticle, anotherParticle);\r\n            }\r\n        }\r\n    }\r\n    gl_FragColor = vec4(selfParticle.velocity, selfParticle.charge);\r\n}\r\n"},749:e=>{e.exports="#if NUM_DIR_LIGHTS > 0\r\nstruct DirectionalLight {\r\n    vec3 direction;\r\n    vec3 color;\r\n    int shadow;\r\n    float shadowBias;\r\n    float shadowRadius;\r\n    vec2 shadowMapSize;\r\n};\r\nuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n#endif\r\n\r\nuniform sampler2D texturePosition;\r\nuniform sampler2D textureVelocity;\r\nuniform float uTime;\r\nuniform float cameraConstant;\r\n\r\nout vec2 particleId;\r\nconst float PI = 3.14159265358979323;\r\nconst float THREE_BY_FOUR_PI = (3.0 / (4.0 * PI));\r\nconst float ONE_THIRD = (1.0 / 3.0);\r\nconst float density = 1.;\r\n\r\nfloat radiusFromMass(float mass) {\r\n    return pow(THREE_BY_FOUR_PI * mass / (density), ONE_THIRD);\r\n}\r\n\r\nvoid main() {\r\n    particleId = uv;\r\n    vec4 posTemp = texture(texturePosition, particleId);\r\n    vec3 pos = posTemp.xyz;\r\n    vec4 velTemp = texture(textureVelocity, particleId);\r\n    vec3 vel = velTemp.xyz;\r\n    float mass = velTemp.w;\r\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\r\n    gl_PointSize = cameraConstant / -mvPosition.z;\r\n    gl_Position = projectionMatrix * mvPosition;\r\n}\r\n"},188:e=>{e.exports="uniform sampler2D pointTexture;\r\nin vec3 vColor;\r\nout vec4 fragColor;\r\n\r\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b)\r\n{\r\n    vec2 pa = p - a, ba = b - a;\r\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\r\n    return length(pa - ba * h);\r\n}\r\n\r\nfloat sdSnowflake(in vec2 p)\r\n{\r\n    const vec2 k = vec2(0.5, -0.86602540378);\r\n    p = p.yx;\r\n    p = abs(p);\r\n    p -= 2.0 * min(dot(k, p), 0.0) * k;\r\n    p = abs(p);\r\n    float d = sdLine(p, vec2(.00, 0), vec2(.75, 0));\r\n    d = min(d, sdLine(p, vec2(.50, 0), vec2(.50, 0) + .10));\r\n    d = min(d, sdLine(p, vec2(.25, 0), vec2(.25, 0) + .15));\r\n    return d - .04;\r\n}\r\n\r\nvoid main() {\r\n    if (length(gl_PointCoord.xy - .5) > .4) discard;\r\n    //fragColor = vec4(vec3(.1/sdSnowflake(1. - 2.*gl_PointCoord.xy)), 1.);\r\n    fragColor = vec4(vColor, 1.0) * texture(pointTexture, gl_PointCoord);\r\n}\r\n"},127:e=>{e.exports="attribute float size;\r\nuniform float uTime;\r\nout vec3 vColor;\r\n\r\nvoid main() {\r\n    vColor = color;\r\n    vec3 pos = position;\r\n\r\n    vec3 shift = vec3(\r\n        .1 * cos(uTime * 10.),\r\n        0.,\r\n        .1 * sin(uTime * 10.)\r\n    );\r\n\r\n    shift.y -= uTime * (size * .01);\r\n    shift.xz /= (size * .01);\r\n    pos += shift;\r\n    pos = mod(pos, 1.) - .5;\r\n\r\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\r\n    gl_PointSize = size * (50. / -mvPosition.z);\r\n    gl_Position = projectionMatrix * mvPosition;\r\n}\r\n"},915:e=>{e.exports="#define PI 3.141592653589793\r\n\r\n#define MAX_STEPS 128\r\n#define MAX_DIST 2000.\r\n#define MIN_DIST .001\r\n#define GAMMA_CORRECTION vec3(0.45454545454545453)\r\n\r\nuniform vec3 rayOrigin;\r\nuniform float uTime;\r\nuniform vec2 resolution;\r\n\r\nin mat3 camera;\r\nin vec3 vPosition;\r\n\r\nout vec4 fragColor;\r\n\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n    float ambient;\r\n    float shininess;\r\n    float receiveShadows;\r\n};\r\n\r\nmat2 rotate2d(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(s, c, c, -s);\r\n}\r\nmat2 rotateq(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(s, c, c, -s);\r\n}\r\nfloat opSmoothUnion(float d1, float d2, float k) {\r\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\r\n    return mix(d2, d1, h) - k*h*(1.0-h);\r\n}\r\nfloat opSmoothSubtraction(float d1, float d2, float k) {\r\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\r\n    return mix(d2, -d1, h) + k*h*(1.0-h); }\r\n\r\nfloat opSmoothIntersection(float d1, float d2, float k) {\r\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\r\n    return mix(d2, d1, h) + k*h*(1.0-h); }\r\nfloat sdBox( vec3 p, vec3 b ) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\nfloat sdBox4 (vec4 p, vec4 b) {\r\n    p = abs(p) - b;\r\n    return min(max(p.x, max(p.y, max(p.z, p.w))), 0.0) + length(max(p, 0.0));\r\n}\r\n\r\nfloat sdBoundingBox(vec3 p, vec3 b, float e) {\r\n    p = abs(p) - b;\r\n    vec3 q = abs(p + e) - e;\r\n    return min(min(length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\r\n    length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\r\n    length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\r\n}\r\nfloat sdBoundingBox4(vec4 p, vec4 b, float e) {\r\n    p = abs(p) - b;\r\n    vec4 q = abs(p + e) - e;\r\n\r\n    //float x3 = length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0);\r\n    float x = length(max(vec4(p.x, q.y, q.z, q.w), 0.0)) + min(max(p.x, max(q.y, max(q.z, q.w))), 0.0);\r\n\r\n    //float y3 = length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0);\r\n    float y = length(max(vec4(q.x, p.y, q.z, q.w), 0.0)) + min(max(q.x, max(p.y, max(q.z, q.w))), 0.0);\r\n\r\n    //float z3 = length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0);\r\n    float z = length(max(vec4(q.x, q.y, p.z, q.w), 0.0)) + min(max(q.x, max(q.y, max(p.z, q.w))), 0.0);\r\n\r\n    float w = length(max(vec4(q.x, q.y, q.z, p.w), 0.0)) + min(max(q.x, max(q.y, max(q.z, p.w))), 0.0);\r\n    //return min(x3, min(y3, z3));\r\n    return min(x, min(y, min(z, w)));\r\n}\r\nfloat sdBoundingBoxes(in vec3 p) {\r\n    float d = MAX_DIST;\r\n    float t = uTime * .05;\r\n    mat2 r;\r\n    for (float i = 1.; i <= 3.; i+= 1.) {\r\n        r = rotate2d(t);\r\n        p.xy *= r;\r\n        p.yz *= r;\r\n        p.zx *= r;\r\n        d = min(d, sdBoundingBox(p, vec3(i), .1));\r\n    }\r\n    return d;\r\n}\r\nfloat sdTorus(in vec3 p, in vec2 t) {\r\n    vec2 q = vec2(length(p.xy)-t.x, p.z);\r\n    return length(q)-t.y;\r\n}\r\nfloat sdDuoCylinder(vec4 p, vec2 t) {\r\n    vec2 q = abs(vec2(length(p.xz), length(p.yw))) - t;\r\n    return min(max(q.x, q.y), 0.) + length(max(q, 0.));\r\n}\r\nfloat sdCircle(in vec2 p, in float r) {\r\n    return length(p) - r;\r\n}\r\nfloat sdSphere(in vec3 p, in float r) {\r\n    return length(p) - r;\r\n}\r\nfloat sdRoundedX( in vec2 p, in float w, in float r ) {\r\n    p = abs(p);\r\n    return length(p-min(p.x + p.y,w) * 0.5) - r;\r\n}\r\nfloat sdRectangle( in vec2 p, in vec2 b ) {\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\nfloat sdTorusKnot(in vec3 p) {\r\n    float r1 = 5.;\r\n    float r2 = .5;\r\n    float thickness = .1;\r\n    vec2 cp = vec2(sdCircle(p.xy, r1), p.z);\r\n    float a = atan(p.x, p.y) * 0.5;\r\n    cp *= rotate2d(a);\r\n    //cp.y = abs(cp.y) - .1;\r\n    return sdRectangle(cp, vec2(r2, thickness)) * .9;\r\n}\r\nfloat sdToruses(in vec3 p) {\r\n    float d = MAX_DIST;\r\n    float t = uTime * .03;\r\n    mat2 r;\r\n    vec3 pt;\r\n    for (float i = 1.; i <= 10.; i+= 1.1) {\r\n        pt = p;\r\n        r = rotate2d(t*i);\r\n        pt.yz *= r;\r\n        pt.xy *= r;\r\n        pt.zx *= r;\r\n        float radius = i-.9;\r\n        float thickness = .2;\r\n        d = opSmoothUnion(d, sdTorus(pt, vec2(radius, thickness)), 2.);\r\n    }\r\n    return d;\r\n}\r\nvec4 mul(vec4 q1, vec4 q2) {\r\n    return vec4(\r\n        q1.w * q2.w + dot(q1.xyz, q2.xyz),\r\n        q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz)\r\n    );\r\n}\r\nvec4 mul(vec4 q, vec3 v) {\r\n    return vec4(\r\n        -q.x * v.x - q.y * v.y - q.z * q.z,\r\n        q.w * v.x + q.y * v.z + q.z * q.y,\r\n        q.w * v.y + q.z * v.x + q.x * q.z,\r\n        q.w * v.z + q.x * v.y + q.y * q.x\r\n    );\r\n}\r\nfloat backWall(vec3 p) {\r\n    return p.z + 30.;\r\n}\r\nfloat sdf(in vec3 p) {\r\n    return min(sdToruses(p), backWall(p));\r\n}\r\nMaterial getMaterial(in vec3 p) {\r\n    Material m;\r\n    m.color = vec3(1., 1., 1.);\r\n    m.diffuse = .4;\r\n    m.specular = 0.2;\r\n    m.ambient = 0.4;\r\n    m.shininess = 1.;\r\n    m.receiveShadows = 1.;\r\n    return m;\r\n}\r\n\r\nfloat raymarch(in vec3 rayOrigin, in vec3 rayDirection) {\r\n    float distance = 0.;\r\n    float stepDistance;\r\n    for (int i = 0; i < MAX_STEPS; i++) {\r\n        stepDistance = sdf(rayOrigin + rayDirection * distance);\r\n        distance += stepDistance;\r\n        if (stepDistance <= MIN_DIST || stepDistance >= MAX_DIST) break;\r\n    }\r\n    return distance;\r\n}\r\n\r\nconst vec2 swizzleStep = vec2(MIN_DIST, 0);\r\nvec3 getNormal(in vec3 p) {\r\n    return normalize(sdf(p) -\r\n    vec3(sdf(p - swizzleStep.xyy), sdf(p - swizzleStep.yxy), sdf(p - swizzleStep.yyx)));\r\n}\r\nfloat softShadow(in vec3 point, in vec3 lightDir) {\r\n    point += lightDir * .1;\r\n    float totalDist = .1;\r\n    float result = 1.;\r\n    float d;\r\n    for (int i = 0; i < 32; i ++) {\r\n        d = sdf(point);\r\n        if (d <= MIN_DIST) return 0.;\r\n        result = min(result, d / (totalDist * .001));\r\n        totalDist += d;\r\n        if (totalDist > 10.) return result;\r\n        point += lightDir * d;\r\n    }\r\n    return result;\r\n}\r\nfloat calcAO(in vec3 p, in vec3 n) {\r\n    float k = 1.;\r\n    float occ = 0.;\r\n    float len;\r\n    for (float i = 1.; i < 6.; i += 1.) {\r\n        len = .15 * i;\r\n        occ += (len - sdf(n * len + p)) * k;\r\n        k *= .5;\r\n    }\r\n    return clamp(1. - occ, 0., 1.);\r\n}\r\nvec3 phongLighting(in vec3 p, in Material mat, in vec3 ray) {\r\n    vec3 normal = getNormal(p);\r\n    vec3 lightPos = vec3(38, 8, 38);\r\n    vec3 lightDir = normalize(lightPos - p);\r\n    float diffuse = max(0., mat.diffuse * dot(normal, lightDir));\r\n    float specular = pow(max(0., mat.specular * dot(lightDir, reflect(ray, normal))), mat.shininess);\r\n    float shadow = mat.receiveShadows * softShadow(p, lightDir) * calcAO(p, normal);\r\n    return (mat.ambient + diffuse * shadow) * pow(mat.color, GAMMA_CORRECTION) + specular * shadow * vec3(1.);\r\n}\r\nvec4 getColor(in vec3 origin, in vec3 direction) {\r\n    float distance = raymarch(origin, direction);\r\n    if (distance >= MAX_DIST) {\r\n        discard;\r\n    }\r\n    vec3 p = origin + direction * distance;\r\n    Material material = getMaterial(p);\r\n    vec3 color = phongLighting(p, material, direction);\r\n    return vec4(color, 1.);//blend(color, FOG_COLOR, hitObject.distance / FOG_DIST);\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = (gl_FragCoord.xy - .5 * resolution.xy) / resolution.y;\r\n    fragColor = getColor(rayOrigin, normalize(camera * vec3(uv, .6)));\r\n}\r\n"},378:e=>{e.exports="uniform float uTime;\r\n\r\nuniform vec3 rayOrigin;\r\nuniform vec3 rayDirection;\r\nout mat3 camera;\r\nout vec3 vPosition;\r\n\r\nvoid setCamera(out mat3 camera) {\r\n    vec3 forward = normalize(rayDirection);\r\n    vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\r\n    vec3 up = normalize(cross(right, forward));\r\n    camera = mat3(right, up, forward);\r\n}\r\n\r\nvoid main() {\r\n    setCamera(camera);\r\n    vPosition = position;\r\n\r\n    vec4 mvPosition = modelViewMatrix * vec4(vPosition, 1.0);\r\n    gl_Position = projectionMatrix * mvPosition;\r\n}\r\n"},130:e=>{e.exports="#define PI 3.141592653589793\r\n\r\n#define MAX_STEPS 128\r\n#define MAX_DIST 100.\r\n#define MIN_DIST .0001\r\n#define GAMMA_CORRECTION vec3(0.45454545454545453)\r\n\r\nuniform vec3 rayOrigin;\r\nuniform float uTime;\r\n\r\nin mat3 camera;\r\nin vec3 vPosition;\r\n\r\nout vec4 fragColor;\r\n\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n    float ambient;\r\n    float shininess;\r\n    float receiveShadows;\r\n};\r\n\r\nmat2 rotate2d(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(s, c, c, -s);\r\n}\r\n\r\nfloat opSmoothUnion( float d1, float d2, float k ) {\r\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\r\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\r\n\r\nfloat sdf(in vec3 p) {\r\n    vec2 t = vec2(1.2, .5);\r\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\r\n    float torus = length(q)-t.y;\r\n    return torus;\r\n}\r\nMaterial getMaterial(in vec3 p) {\r\n    Material m;\r\n    m.color.rg = vec2(1.5-vPosition*.003);\r\n    m.diffuse = .3;\r\n    m.specular = .2;\r\n    m.ambient = .2;\r\n    m.shininess = 1.;\r\n    m.receiveShadows = 1.;\r\n    return m;\r\n}\r\n\r\nfloat raymarch(in vec3 rayOrigin, in vec3 rayDirection) {\r\n    float distance = 0.;\r\n    float stepDistance;\r\n    for (int i = 0; i < MAX_STEPS; i++) {\r\n        stepDistance = sdf(rayOrigin + rayDirection * distance);\r\n        distance += stepDistance;\r\n        if (stepDistance <= MIN_DIST || stepDistance >= MAX_DIST) break;\r\n    }\r\n    return distance;\r\n}\r\n\r\nvec3 getNormal(in vec3 p) {\r\n    const vec2 swizzleStep = vec2(MIN_DIST, 0);\r\n    return normalize(sdf(p) - vec3(\r\n        sdf(p - swizzleStep.xyy),\r\n        sdf(p - swizzleStep.yxy),\r\n        sdf(p - swizzleStep.yyx)\r\n    ));\r\n}\r\nfloat softShadow(in vec3 point, in vec3 lightDir) {\r\n    return 1.;\r\n    /*point += lightDir * .1;\r\n    float totalDist = .1;\r\n    float result = 1.;\r\n    float d;\r\n    for ( int i = 0; i < 32; i ++ ) {\r\n        d = sdf(point);\r\n        if (d <= MIN_DIST) return 0.;\r\n        result = min(result, d / (totalDist * .001));\r\n        totalDist += d;\r\n        if (totalDist > 10.) return result;\r\n        point += lightDir * d;\r\n    }\r\n    return result;*/\r\n}\r\nfloat calcAO(in vec3 p, in vec3 n) {\r\n    return 1.;\r\n    /*float k = 1.;\r\n    float occ = 0.;\r\n    float len;\r\n    for ( float i = 1.; i < 6.; i += 1. ) {\r\n        len = .15 * i;\r\n        occ += (len - sdf(n * len + p)) * k;\r\n        k *= .5;\r\n    }\r\n    return clamp(1. - occ, 0., 1.);*/\r\n}\r\nvec3 phongLighting(in vec3 p, in Material mat, in vec3 ray) {\r\n    vec3 normal = getNormal(p);\r\n    vec3 lightPos = vec3(-1, -1, 3);\r\n    vec3 lightDir = normalize(lightPos - p);\r\n    float diffuse = max(0., mat.diffuse * dot(normal, lightDir));\r\n    float specular = pow(max(0., mat.specular * dot(lightDir, reflect(ray, normal))), mat.shininess);\r\n    float shadow = mat.receiveShadows * softShadow(p, lightDir) * calcAO(p, normal);\r\n    return (mat.ambient + diffuse * shadow) * pow(mat.color, GAMMA_CORRECTION) + specular * shadow * vec3(1.);\r\n}\r\nvec4 getColor(in vec3 origin, in vec3 direction) {\r\n    float distance = raymarch(origin, direction);\r\n    if (distance >= MAX_DIST) {\r\n        discard;\r\n    }\r\n    vec3 p = origin + direction * distance;\r\n    Material material = getMaterial(p);\r\n    vec3 color = phongLighting(p, material, direction);\r\n    return vec4(color, 1.);//blend(color, FOG_COLOR, hitObject.distance / FOG_DIST);\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = gl_PointCoord - vec2(.5);\r\n    // fragColor = getColor(rayOrigin, normalize(camera * vec3(uv, .6)));\r\n    fragColor = getColor(vec3(0,0,3), normalize(camera * vec3(uv, .6)));\r\n    //if (length(gl_PointCoord.xy - .5) > .5) discard;\r\n    //fragColor = vec4(vec3(0), 1.0);\r\n}\r\n"},354:e=>{e.exports="uniform float uTime;\r\n\r\nuniform vec3 rayOrigin;\r\nuniform vec3 rayDirection;\r\nout mat3 camera;\r\nout vec3 vPosition;\r\n\r\nvoid setCamera(out mat3 camera) {\r\n    vec3 rayDirection = vec3(0, 0, -1);\r\n    vec3 forward = normalize(rayDirection);\r\n    vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\r\n    vec3 up = normalize(cross(forward, right));\r\n    camera = mat3(right, up, forward);\r\n}\r\n\r\nvec3 getPosition(in vec3 p) {\r\n    float t = uTime * .5;\r\n    p.x -= 50. * cos((p.x)*.01 - t);\r\n    p.z -= 50. * sin((p.x-p.y)*.01 - t);\r\n    p.y -= 50. * sin((p.y*p.y*.001-p.x)*.01 - t);\r\n    return p;\r\n}\r\n\r\nvoid main() {\r\n    setCamera(camera);\r\n    vPosition = getPosition(position);\r\n\r\n    vec4 mvPosition = modelViewMatrix * vec4(vPosition, 1.0);\r\n    gl_Position = projectionMatrix * mvPosition;\r\n    gl_PointSize = (30000. / -mvPosition.z);\r\n}\r\n"},497:(e,r,t)=>{var n={"./kubik":[959,959],"./kubik.ts":[959,959]};function i(e){if(!t.o(n,e))return Promise.resolve().then((()=>{var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}));var r=n[e],i=r[0];return t.e(r[1]).then((()=>t(i)))}i.keys=()=>Object.keys(n),i.id=497,e.exports=i},57:(e,r,t)=>{var n={"./cube":[431],"./cube.ts":[431],"./flat":[121],"./flat.ts":[121],"./four":[835,835],"./four.ts":[835,835],"./random":[546],"./random.ts":[546],"./two":[910,910],"./two.ts":[910,910]};function i(e){if(!t.o(n,e))return Promise.resolve().then((()=>{var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}));var r=n[e],i=r[0];return Promise.all(r.slice(1).map(t.e)).then((()=>t(i)))}i.keys=()=>Object.keys(n),i.id=57,e.exports=i}},n={};function i(e){if(n[e])return n[e].exports;var r=n[e]={id:e,exports:{}};return t[e](r,r.exports,i),r.exports}i.m=t,i.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return i.d(r,{a:r}),r},i.d=(e,r)=>{for(var t in r)i.o(r,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},i.f={},i.e=e=>Promise.all(Object.keys(i.f).reduce(((r,t)=>(i.f[t](e,r),r)),[])),i.u=e=>e+"-"+e+".js",i.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),e={},r="three-page-application:",i.l=(t,n,o)=>{if(e[t])e[t].push(n);else{var a,s;if(void 0!==o)for(var l=document.getElementsByTagName("script"),c=0;c<l.length;c++){var d=l[c];if(d.getAttribute("src")==t||d.getAttribute("data-webpack")==r+o){a=d;break}}a||(s=!0,(a=document.createElement("script")).charset="utf-8",a.timeout=120,i.nc&&a.setAttribute("nonce",i.nc),a.setAttribute("data-webpack",r+o),a.src=t),e[t]=[n];var h=(r,n)=>{a.onerror=a.onload=null,clearTimeout(u);var i=e[t];if(delete e[t],a.parentNode&&a.parentNode.removeChild(a),i&&i.forEach((e=>e(n))),r)return r(n)},u=setTimeout(h.bind(null,void 0,{type:"timeout",target:a}),12e4);a.onerror=h.bind(null,a.onerror),a.onload=h.bind(null,a.onload),s&&document.head.appendChild(a)}},i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.p="",(()=>{var e={179:0},r=[[559,245]];i.f.j=(r,t)=>{var n=i.o(e,r)?e[r]:void 0;if(0!==n)if(n)t.push(n[2]);else{var o=new Promise(((t,i)=>{n=e[r]=[t,i]}));t.push(n[2]=o);var a=i.p+i.u(r),s=new Error;i.l(a,(t=>{if(i.o(e,r)&&(0!==(n=e[r])&&(e[r]=void 0),n)){var o=t&&("load"===t.type?"missing":t.type),a=t&&t.target&&t.target.src;s.message="Loading chunk "+r+" failed.\n("+o+": "+a+")",s.name="ChunkLoadError",s.type=o,s.request=a,n[1](s)}}),"chunk-"+r)}};var t=()=>{};function n(){for(var t,n=0;n<r.length;n++){for(var o=r[n],a=!0,s=1;s<o.length;s++){var l=o[s];0!==e[l]&&(a=!1)}a&&(r.splice(n--,1),t=i(i.s=o[0]))}return 0===r.length&&(i.x(),i.x=()=>{}),t}i.x=()=>{i.x=()=>{},a=a.slice();for(var e=0;e<a.length;e++)o(a[e]);return(t=n)()};var o=n=>{for(var o,a,[l,c,d,h]=n,u=0,m=[];u<l.length;u++)a=l[u],i.o(e,a)&&e[a]&&m.push(e[a][0]),e[a]=0;for(o in c)i.o(c,o)&&(i.m[o]=c[o]);for(d&&d(i),s(n);m.length;)m.shift()();return h&&r.push.apply(r,h),t()},a=self.webpackChunkthree_page_application=self.webpackChunkthree_page_application||[],s=a.push.bind(a);a.push=o})(),i.x()})();