(self.webpackChunkthree_page_application=self.webpackChunkthree_page_application||[]).push([[959],{959:(r,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>u});var e=n(538),o=n(273),i=n.n(o),a=n(20),l=n.n(a),c=n(784),p=n.n(c),s=n(922),v=n.n(s);const f={id:"kubik",count:Math.pow(729,2),vertexShader:p(),fragmentShader:v(),positionShader:i(),velocityShader:l(),fillPositions:r=>{const t=.8696464646;for(let n=0,o=4*f.count;n<o;n+=4){let o=e.Z.cubePosition(n/4,81,.01);r[n]=o[0]-t,r[n+1]=o[1]-t,r[n+2]=o[2]-t,r[n+3]=0}},fillVelocities:r=>{for(let t=0,n=4*f.count;t<=n;t+=4)r[t]=0,r[t+1]=0,r[t+2]=0,r[t+3]=0}},u=f},922:r=>{r.exports="uniform sampler2D texturePosition;\r\nuniform sampler2D textureVelocity;\r\nuniform float dt;\r\nuniform float t;\r\nin vec2 particleId;\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    vec2 uv = gl_PointCoord - vec2(.5);\r\n    float cUv = length(uv);\r\n    if (cUv > .5) discard;\r\n    vec3 velocity = texture(textureVelocity, particleId).xyz;\r\n    vec3 particleColor = (1. - normalize(velocity)) * .5;\r\n    fragColor = vec4(particleColor, 1.);\r\n}\r\n"},273:r=>{r.exports="uniform float time;\r\n\r\nvoid main() {\r\n    vec2 particleId = gl_FragCoord.xy / resolution.xy;\r\n    vec3 position = texture(texturePosition, particleId).xyz;\r\n    vec3 velocity = texture(textureVelocity, particleId).xyz;\r\n    gl_FragColor = vec4(position + velocity, 1.);\r\n}\r\n"},20:r=>{r.exports="uniform float t;\r\nuniform float dt;\r\nconst float width = resolution.x;\r\nconst float height = resolution.y;\r\nconst vec2 size = vec2(width, height);\r\n\r\nstruct Particle {\r\n    vec3 position;\r\n    vec3 velocity;\r\n    float charge;\r\n    float mass;\r\n};\r\n\r\nvoid fetchParticle(in vec2 uv, out Particle particle) {\r\n    vec4 positionData = texture2D(texturePosition, uv);\r\n    vec4 velocityData = texture2D(textureVelocity, uv);\r\n    particle.position = positionData.xyz;\r\n    particle.velocity = velocityData.xyz;\r\n    particle.mass = positionData.w;\r\n    particle.charge = velocityData.w;\r\n}\r\n\r\nvec3 lorenzAttractor(in vec3 p, in float t, in float dt) {\r\n    dt *= 3.;\r\n    float a = 10. + 3. * cos(t);\r\n    const float b = 28.;\r\n    const float c = 8./3.;\r\n    return dt * vec3(\r\n        a * (p.y - p.x),\r\n        p.x * (b - p.z) - p.y,\r\n        p.x * p.y - c * p.z\r\n    );\r\n}\r\n\r\nvec3 aizawaAttractor(in vec3 p, in float t, in float dt) {\r\n    float a = .95;\r\n    float b = .7;\r\n    float c = .6;\r\n    float d = 3.5;\r\n    float e = .25;\r\n    float f = .01;\r\n    return dt * vec3(\r\n    (p.z - b) * p.x - d * p.y,\r\n    d * p.x + (p.z - b) * p.y,\r\n    c + a * p.z - pow(p.z, 3.) / 3. - p.x * p.x + f * p.z * pow(p.x, 3.)\r\n    );\r\n}\r\n\r\nvec3 halvorsenAttractor (in vec3 p, in float t, in float dt) {\r\n    float a = 1.4;\r\n    return dt * vec3(\r\n    -a * p.x - 4. * p.y - 4. * p.z - p.y * p.y,\r\n    -a * p.y - 4. * p.z - 4. * p.x - p.z * p.z,\r\n    -a * p.z - 4. * p.x - 4. * p.y - p.x * p.x\r\n    );\r\n}\r\n\r\nvec3 thomasAttractor(in vec3 p, in float phase, in float dt) {\r\n    dt *= 100.;\r\n    float b = .173 + .07 * cos(phase);\r\n    return dt * vec3(\r\n        sin(p.y) - b * p.x,\r\n        sin(p.z) - b * p.y,\r\n        sin(p.x) - b * p.z\r\n    );\r\n}\r\n\r\nvoid main() {\r\n    Particle selfParticle, anotherParticle;\r\n    vec2 selfId, anotherId;\r\n    selfId = gl_FragCoord.xy / size;\r\n    fetchParticle(selfId, selfParticle);\r\n\r\n    selfParticle.velocity = thomasAttractor(selfParticle.position, t, dt);\r\n    gl_FragColor = vec4(selfParticle.velocity, selfParticle.charge);\r\n}\r\n"},784:r=>{r.exports="uniform sampler2D texturePosition;\r\nuniform sampler2D textureVelocity;\r\nuniform float uTime;\r\nuniform float cameraConstant;\r\n\r\nout vec2 particleId;\r\n\r\nvoid main() {\r\n    particleId = uv;\r\n    vec4 posTemp = texture(texturePosition, particleId);\r\n    vec3 pos = posTemp.xyz;\r\n    vec4 velTemp = texture(textureVelocity, particleId);\r\n    vec3 vel = velTemp.xyz;\r\n    float mass = velTemp.w;\r\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\r\n    gl_PointSize = cameraConstant / -mvPosition.z;\r\n    gl_Position = projectionMatrix * mvPosition;\r\n}\r\n"}}]);